import { Article } from '../../../components/layouts/Article';
import meta from './meta.json';

export default ({ children }) => (
	<Article
		{...meta}
		img={require('./feature.jpg').default.src}
		socialMediaImg={require('./twitter.png').default.src}
		intro="A broad intro to many of the e-Reader's card types"
	>
		{children}
	</Article>
);

<wisdom>
	This blog post is a beast and I am tackling it in chunks. It is not done yet.
	Long term I'm not sure my blog is the right home for this, but for now that's
	where this lives.
</wisdom>

The Game Boy Advance e-Reader is an obscure, and not too successful peripheral that Nintendo released in 2001. It's actually a pretty complex device, with many different ways to make cards for it. This post is a broad overview of most of these ways, with some launching points for further digging on the approaches that interest you.

# Table of contents

- [Standalone vs Supplementary cards](#standalone-vs-supplementary-cards)
- [Standalone: z80 Games](#standalone-z80-games)
- [Standalone: native ARM Games](#standalone-native-arm-games)
- [Standalone: NES Games](#standalone-nes-games)
- [Super Mario Advance 4: level cards](#super-mario-advance-4-level-cards)
  - [Loading the level into mGBA](#loading-the-level-into-mgba)

## Standalone vs Supplementary cards

E-Reader cards can either be completely their own thing (usually mini games), or a way to enhance a mainline GBA or GameCube game, similar to modern DLC.

<figure>
	<img src={require('./manholeAndAirHockey.jpg').default.src} />
	<figcaption>
		The US version of Manhole and the Japanese version of Air Hockey
	</figcaption>
</figure>

Manhole and Air Hockey are good examples of a standalone cards. You swipe these cards in directly and play them.

There were many type of companion (DLC) cards. The bonus level cards for Super Mario Advance 4 are a good example.

<figure>
	<img
		src={
			require('../cramming-solitaire-onto-a-nintendo-ereader-card/sma4LevelCards.jpg')
				.default.src
		}
	/>
	<figcaption>Super Mario Advance 4 level cards</figcaption>
</figure>

## Standalone: z80 Games

Arguably the most "definitive" type of e-Reader card, all official standalone game cards (except for NES games) were made using z80 assembly. The e-Reader contains a z80 emulator in order to run these cards.

<wisdom>
	It really is an emulator. The GBA also has the original Game Boy's CPU
	present, which is z80 derived. But GBA games are locked out of this CPU, so
	the e-Reader can not make use of it.
</wisdom>

The z80 emulator is slow and very limited. Games made in this way are probably best not being too action oriented.

<wisdom>
	Not to say action oriented games are not possible. My shooter, Exo Attack, is
	a z80 game.{' '}
	<a href="/blog/making-a-shooter-for-the-ereader/">
		Here is a post on its creation.
	</a>
</wisdom>

### z80: Pros

- Most space efficient; z80 assembly is compact and so a game will require fewer dot strips (thus fewer cards) compared to other ways to make an e-Reader game.
- Simple, at least as far as assembly goes. z80 assembly is pretty easy to learn.
- It's possible to make use of general z80 tooling, such as emulators, debuggers and more.

### z80: Cons

- The emulator is very slow. It is easy to do too much and kill the game's frame rate.
- The emulator is limited. Not all opcodes are supported.
- Poor debugging experience compared to native e-Reader games.
- Assembly can be really rough at times.

### z80: Getting Started

I wrote an [introductory tutorial](/blog/ereader-z80-tutorial-part1/) that is a good jumping off point. From there, these resources will come in handy:

- [This blog](/blog/E-Reader/), I have written several articles on e-Reader z80 development.
- [The e-Reader dev wiki](https://ereader.miraheze.org/wiki/Main_Page) mostly focuses on z80 (so far).
- [My Solitaire game](https://github.com/city41/ereader-solitaire), an open source z80 e-Reader game.
- [My Bomb Hunter game](https://github.com/city41/ereader-bomb-hunter), another open source z80 e-Reader game.

## Standalone: native ARM Games

<wisdom>
	I use the term "ARM" in this post, but in actuality these games are built
	using Thumb.
</wisdom>

E-Reader games can also be made with native ARM machine code. After the card is loaded into memory, it then runs natively on the GBA's CPU and for the most part acts just like a cartridge game.

You could write these games in ARM/Thumb assembly, but it is more common to use C. This is a mixed bag, but overall C provides more upside than downside in my opinion. Things that can be tricky in assembly, like nested loops, are a breeze in comparison.

### ARM: Pros

- Native speed. No slow and clunky emulator to get in your way. The speed difference between native and z80 games can be absolutely astonishing.
- C is usually more pleasant to work with than assembly.
- Using mGBA and gdb, a full fledged debugging experience is possible.

### ARM: Cons

- The resulting game usually requires much more space than an equivalent z80 game. An ARM native game will pretty much always require more dot strips (ie cards), often twice as many.
- Getting the C environment set up and fully working can be a pain. Thankfully it's virtually identical to mainstream GBA development.
- It can be tricky to get C to work effectively in such a constrained environment. You need to be vigilant about not including libraries you don't need, and sometimes gcc's optimizations will break the game. These concerns don't exist at all with z80 assembly, which is much more of a "what you see is what you get" environment.
- ARM games are still ran under the supervision of the e-Reader. Truly breaking out and taking full control of the GBA means you will be fighting the e-Reader every step of the way. This is not recommended.

### ARM: Getting Started

[This github repo](https://github.com/AkBKukU/e-reader-dev) is the ideal way to start with ARM e-Reader dev. The base underpinning is [DevKitPro](https://devkitpro.org/wiki/Getting_Started), the primary toolkit for standard GBA dev. It might be easiest to make sure DevKitPro is working properly by building a simple GBA Hello World app, then from there extending into getting the [e-Reader example project](https://github.com/AkBKukU/e-reader-dev/tree/main/projects/example-project) running. Once you've got that project going, you're pretty much golden.

There are some gotchas around ARM e-Reader development (such as dividing two numbers) and there's very little documentation or guides out there. I hope to fill that gap over time.

## Standalone: NES Games

The e-Reader also contains an NES emulator. This is how Nintendo released all of the NES games for the e-Reader

<figure>
	<img
		src={
			require('../cramming-solitaire-onto-a-nintendo-ereader-card/excitebike.jpg')
				.default.src
		}
	/>
	<figcaption>The NES game, Excitebike, in e-Reader card format</figcaption>
</figure>

<pitfall>
	Of the three standalone approaches, I know the least about NES. I've never
	made an NES e-Reader game. Heck, I've never made an NES game, period.
</pitfall>

For an NES game to run on the e-Reader, it needs to be small, and only use the base mapper. Think Nintendo's black box games. But then think even more constrained than that; for example Super Mario Bros is too big to fit on the e-Reader.

According to [Tim Schuerewegen](https://web.archive.org/web/20040730032343/http://users.skynet.be/firefly/gba/e-reader/nescomp.htm), even many black box games do not work. Tim did a lot of work on reverse engineering the e-Reader back in the day.

### Converting an NES rom

To run an NES rom on the e-Reader, first grab the e-Reader dev tools from [here](https://www.caitsith2.com/ereader/devtools.htm), or [here](https://github.com/AkBKukU/e-reader-dev/tree/main/bin) for native Linux versions. For OSX, you can either use the Windows versions through wine, or compile them from [here](https://github.com/breadbored/nedclib).

Then grab [demo.nes](https://github.com/christopherpow/nes-test-roms/blob/master/other/demo.nes). Why that specific rom? It has no copyright implications so I can freely recommend it. But more importantly, it is the only NES rom I've successfully converted. Like I said, NES e-Reader is not my forte.

#### Convert with nedcmake

NES roms are almost always in iNES format, with a `.nes` file extension. `nedcmake` knows how to deal with iNES roms directly, so it's as simple as:

```bash
 nedcmake -i demo.nes -o demo -region 1 -name 'demo' -type 0 -raw
```

It will spit out `demo-01.raw` and `demo-02.raw`. Load up the e-Reader in mGBA. Then from the file menu choose "Scan e-Reader dotcodes..." and select those two raw files. Then start scanning with the e-Reader and it will scan them in and then play it.

<figure>
	<img
		src={require('./demoRunning.png').default.src}
		style={{ imageRendering: 'pixelated' }}
	/>
	<figcaption>The Demo rom running on the e-reader</figcaption>
</figure>

<pitfall>
	The Linux version of nedcmake crashes for me on this rom. The Windows version
	succeeds though. nedcmake, both the Linux and Windows versions, crashes a lot.
	It is on my list to dig in and fix these bugs, but I've not gotten to it
	yet...
</pitfall>

#### Using neflmake?

neflmake is similar to nedcmake except instead of raw files, it makes sav files. It simulates scanning in an e-Reader card then saving it to the e-Reader. For development, sav files are much more convenient. I do not believe neflmake understands iNES roms. I was able to get demo.nes to work with neflmake by first chopping off the 16 bit iNES header, compressing it with `nevpk`, and then running it through `neflmake`. However, when I do that, the main character of the demo (you can see them above at the bottom of the screenshot) is missing. So I'm unsure if `neflmake` is a valid way to load NES games or not.

## NES: Resources

There doesn't seem to be too much out there about NES dev and the e-Reader. But [Sarah Lynne wrote a good post on NES e-reader dev here](https://igwgames.com/blog/2025/06/22/making-a-game-for-the-e-reader-using-nes-tools/) that is definitely recommended reading.

## Super Mario Advance 4: level cards

Now we are moving away from standalone cards into supplementary cards. We'll start with Super Mario Advance 4 level cards.

Nintendo released a set of bonus levels for the game as e-Reader cards.

<figure>
	<img
		src={
			require('../cramming-solitaire-onto-a-nintendo-ereader-card/sma4LevelCards.jpg')
				.default.src
		}
	/>
	<figcaption>Super Mario Advance 4 level cards</figcaption>
</figure>

Making your own is pretty simple.

### Create a level in Smaghetti

[Smaghetti](https://smaghetti.mattgreer.dev) is a SMA4 level editor I created. You will need the version 1.1 rom of SMA4 for the GBA. If your SMA4 rom won't load, it's likely the 1.0 version. Once in Smaghetti, design your level. You can also [choose one of the many existing levels](https://smaghetti.mattgreer.dev/levels/all/popular/).

<figure>
	<img src={require('./smaghettiEditor.png').default.src} />
	<figcaption>Designing a level in Smaghetti</figcaption>
</figure>

Once you are happy with your level, click on the beaker icon in the lower right. In the dialog that pops up, click on "Download level as .bin".

<figure>
	<img src={require('./downloadAsBin.png').default.src} />
	<figcaption>The experiments dialog in Smaghetti</figcaption>
</figure>

You will get a `.bin` file that is your level. This is a SMA4 level e-Reader card in its binary format.

### Loading the level into mGBA

You can now load your level into SMA4 using mGBA. This involves a few steps.

First, load up mGBA then select "New multiplayer window" from the File menu. You will end up with two instances of mGBA. Load your SMA4 rom into the first window, and your e-Reader rom into the second. It is important to do it this way, if you flip the roms, it won't work. If you do make this mistake, you will get communication errors when trying to get the two to talk to each other.

<figure>
	<img src={require('./mgbaMultiStart.png').default.src} />
	<figcaption>mGBA in multiplayer mode</figcaption>
</figure>

In your SMA4 rom, choose single player, then Super Mario Bros. 3, and then the Level Card save slot. You will be dropped into the e-Reader world.

<figure>
	<img
		src={require('./sma4EreaderWorld.png').default.src}
		style={{ imageRendering: 'pixelated' }}
	/>
	<figcaption>The SMA4 e-Reader world</figcaption>
</figure>

<wisdom>
	Fun fact, the small island in this world is shaped like the e-Reader logo.
</wisdom>

In the e-Reader world in SMA4, navigate into the central small island with the rounded white rectangle on it. Then choose the "Level Card" button.

<figure>
	<img
		src={require('./sma4LevelCardButton.png').default.src}
		style={{ imageRendering: 'pixelated' }}
	/>
	<figcaption>The Level Card button at the top</figcaption>
</figure>

This will take you into the e-Reader level card loader.

<figure>
	<img
		src={require('./sma4PreparingToCommunicate.png').default.src}
		style={{ imageRendering: 'pixelated' }}
	/>
	<figcaption>SMA4 ready to communicate with the e-Reader</figcaption>
</figure>

Now over on the e-Reader side of mGBA, choose Communcation > To Game Boy Advance. This screen will pop up.

<figure>
	<img
		src={require('./ereaderPressAToConnect.png').default.src}
		style={{ imageRendering: 'pixelated' }}
	/>
	<figcaption>The e-Reader ready to communicate</figcaption>
</figure>

Now, press A on the e-Reader side, then A on the SMA4 side. They will connect and the e-Reader side will load the SMA4 level loader app.

<figure>
	<img src={require('./sma4PleaseScanACard.png').default.src} />
	<figcaption>
		Now the whole shebang finally ready to scan in a level card
	</figcaption>
</figure>

On the e-Reader side of mGBA, choose "Scan e-Reader dotcodes..." from the File menu, and choose your .bin file you made with Smaghetti. That level will get loaded and ready to play over in SMA4.

<figure>
	<img
		src={require('./smaghettiLevelLoaded.png').default.src}
		style={{ imageRendering: 'pixelated' }}
	/>
	<figcaption>The level from Smaghetti ready to be played</figcaption>
</figure>

### Printing out your Smaghetti level

The `.bin` file that Smaghetti made will really only work in mGBA. If you want to make an actual e-Reader card out of it, you will need to first encode it into a `.raw`. Thankfully that is easy.

Grab the e-reader dev tools as noted above in "Converting an NES rom". Then do:

```bash
nedcenc -i smaghetti.bin -o smaghetti.raw -e
```

The resulting .raw file is now ready to turn into an image for printing.

```bash
raw2bmp -i smaghetti.raw -o smaghetti -dpi 1200
```

<wisdom>
	You can also use the raw file in mGBA exactly how you used the .bin file
	before. They are interchangable in that scenario.
</wisdom>

Printing out scannable e-Reader cards is its own giant can of worms. I won't get into any of it here in this post, but if curious, [I've written extensively about it.](/blog/E-Reader-Printing/)

### Warning: All levels created this way have the same id

Each e-Reader SMA4 level has a unique ID so the game can tell them apart. So far my little .bin creator just uses the same ID every time. I will fix this, but for now, be aware that this approach won't work well with more than one level.

## To be continued...

I hope to cover most e-Reader card types in this blog post. There are many different types and I expect this post to be very long. So I've decided to tackle it in chunks.
